# Leetcode(Algorithm-Pattern)

* Starting from 2020/08/02
* Leetcode practice with Python (for now)
* Daily Challenge + Selected Questions From [algorithm-pattern](https://github.com/greyireland/algorithm-pattern)
* Using Leetcode Plugin for [Visual Studio Code](https://marketplace.visualstudio.com/items?itemName=LeetCode.vscode-leetcode)

## Solutions

|  ID  |                 English Title                  |         中文题目名称          |                         Category                          |                          Notes URI                           |                         Description                          |
| :--: | :--------------------------------------------: | :---------------------------: | :-------------------------------------------------------: | :----------------------------------------------------------: | :----------------------------------------------------------: |
|  3   | Longest Substring Without Repeating Characters |     无重复字符的最长子串      |                 滑动窗口 / Sliding window                 | 两个循环，一个起始点，一个结束点，外层循环起始点每次后移，把对应头元素移出hashset，内循环结束点从0开始一直到len(s)或出现重复结束，每次外循环可以计算一次最大值 |              algorithm-pattern: sliding window               |
|  17  |     Letter Combinations of a Phone Number      |      电话号码的字母组合       |            回溯法，递归 / Backtrack，Recursion            |                          回溯+递归                           |                  Daily Challenge 2020/08/26                  |
|  20  |               Valid Parentheses                |          有效的括号           |                        Stack / 栈                         |                         用栈实现配对                         |                  Daily Challenge 2020/08/14                  |
|  21  |             Merge Two Sorted Lists             |       合并两个有序链表        |                    Linked List / 链表                     | 每次比较l1 l2取小的那个加入合并链表，需要使用dummy node，以及注意处理l1 l2剩余的元素 |                algorithm-pattern: linked list                |
|  28  |               Implement strStr()               |         实现 strStr()         |                      String / 字符串                      |                         循环遍历即可                         |                algorithm-pattern: quick start                |
|  33  |         Search in Rotated Sorted Array         |       搜索旋转排序数组        |                 Binary Search / 二分查找                  | 计算mid之后，mid左右两侧一定有一边有序，另一边被旋转打乱。我们可以判断target是否在有序的那一边，以此来将搜索空间每次缩小一半 |               algorithm-pattern: binary search               |
|  35  |             Search Insert Position             |         搜索插入位置          |                 Binary Search / 二分查找                  | 在二分查找的模板基础上，对于没搜索到的情况加一个分三种情况的判断 |               algorithm-pattern: binary search               |
|  43  |                Multiply Strings                |          字符串相乘           |                      String / 字符串                      | [md](https://github.com/williamlwclwc/leetcode/blob/master/Notes/43.multiply-strings.md) |                  Daily Challenge 2020/08/13                  |
|  46  |                  Permutations                  |            全排列             |                     回溯 / backtrack                      |   回溯法，每次新添加时判断所有元素，如果当前没选过则可以选   |                 algorithm-pattern: backtrack                 |
|  47  |                Permutations ii                 |           全排列 ii           |                     回溯 / backtrack                      | 处理带重复，先排序，然后添加时判断是否和前一个相等，相等就不再添加 |                 algorithm-pattern: backtrack                 |
|  55  |                   Jump Game                    |           跳跃游戏            |                       贪心 / greedy                       | 每次循环取当前能到达的最大位置和i + nums[i]的较大者，如果无法到达下一个i则False |                    algorithm-pattern: DP                     |
|  62  |                  Unique Paths                  |           不同路径            |                       动态规划 / DP                       |  思考递归五要素，先初始化第一行第一列，然后依次按行填表即可  |                    algorithm-pattern: DP                     |
|  63  |                Unique Paths ii                 |          不同路径 ii          |                       动态规划 / DP                       | 遇上一题相同，障碍物以及被障碍物阻挡的dp值均为0，注意初始化过程 |                    algorithm-pattern: DP                     |
|  64  |                Minimum Path Sum                |          最短路径和           |                       动态规划 / DP                       | dp或递归memo均可，思考五要素。递归从右下角结果出发，dp从左上角起点开始逐行填表 |                    algorithm-pattern: DP                     |
|  70  |                Climbing Stairs                 |            爬楼梯             |                       动态规划 / DP                       |                   此题可以转化为Fibonacci                    |                    algorithm-pattern: DP                     |
|  72  |                 Edit Distance                  |           编辑距离            |                       动态规划 / DP                       | [参考题解及可视化辅助练习](https://leetcode-cn.com/problems/edit-distance/solution/shi-pin-jiang-jie-bian-ji-ju-chi-dong-tai-gui-hua-/) |                    algorithm-pattern: DP                     |
|  74  |               Search a 2D Matrix               |         搜索二维矩阵          |                 Binary Search / 二分查找                  |  将二维矩阵展开为有序的线性数组，之后按模板使用二分查找即可  |               algorithm-pattern: binary search               |
|  76  |            Minimum Window Substring            |         最小覆盖子串          |                 Sliding Window / 滑动窗口                 | 移动右边界来找到一个子串包含t中所有字符，优先移动右边界；在已经找到包含所有字符的子串后，移动左边界来尝试缩小子串长度以找到更小的子串 |              algorithm-pattern: sliding window               |
|  78  |                    Subsets                     |             子集              |                     回溯 / backtrack                      | 标准回溯法，[参考解析](https://leetcode-cn.com/problems/subsets/solution/78zi-ji-hui-su-fa-xiang-jie-pythonshi-xi-2aul/) |                algorithm-pattern: quick start                |
|  81  |       Search in Rotated Sorted Array II        |       搜索旋转排序数组        |                 Binary Search / 二分查找                  | 和上一题类似，但是由于有重复元素，所以可能会出现mid = start = end的情况导致无法判断是否有序，处理方式是遇到重复就移一位跳过重复的元素 |               algorithm-pattern: binary search               |
|  82  |     Remove Duplicates From Sorted List ii      |  删除排序链表中的重复元素ii   |                    Linked List / 链表                     | 需要用到dummy节点(新建一个节点其next指向head)处理移除头节点的情况，循环比较next和next next的值，如果相等则删除一个并记录删除的值，如果退出循环后next与删除的值相同则需要再额外删掉next，否则遍历指针p后移 |                algorithm-pattern: linked list                |
|  83  |       Remove Duplicates From Sorted List       |   删除排序链表中的重复元素    |                    Linked List / 链表                     |  遍历链表，循环删除相邻重复的元素即可，需要注意边界条件判断  |                algorithm-pattern: linked list                |
|  84  |         Largest Rectangle in Histogram         |      柱状图中的最大矩形       |                        Stack / 栈                         | 使用辅助栈优化暴力搜索，[参考解析](https://leetcode-cn.com/problems/largest-rectangle-in-histogram/solution/zhao-liang-bian-di-yi-ge-xiao-yu-ta-de-zhi-by-powc/) |               algorithm-pattern: stack & queue               |
|  86  |                 Partition List                 |           分隔链表            |                    Linked List / 链表                     | 分别使用两个dummy node将小于x和大于等于x的元素放入，之后再将两部分接起来，注意遍历结束后两部分链表结尾都应是None |                algorithm-pattern: linked list                |
|  90  |                   Subsets ii                   |            子集 ii            |                     回溯 / backtrack                      |      78题基础上，对每次添加新元素时加一个是否重复的判断      |                 algorithm-pattern: backtrack                 |
|  92  |             Reverse Linked List ii             |          翻转链表ii           |                    Linked List / 链表                     | 翻转m-n位置，先遍历到m，再翻转m-n(见206)，最后再拼接三段。注意保存翻转片段前一个位置，翻转片段开始位置(即翻转后最后一个元素)。使用dummy node处理头节点的corner case |                algorithm-pattern: linked list                |
|  93  |              Restore IP Addresses              |          复原IP地址           |                     Recursion / 递归                      | [md](https://github.com/williamlwclwc/leetcode/blob/master/Notes/93.restore-ip-addresses.md) |                  Daily Challenge 2020/08/09                  |
|  94  |         Binary Tree Inorder Traversal          |       二叉树的中序遍历        |     Binary Tree, Stack, Recursion / 二叉树、栈、递归      | 可以用递归和栈两种方式，使用栈时注意顺序: 先将root向左的全部节点都入栈，之后在pop访问当前root，再将root移向right |               algorithm-pattern: stack & queue               |
|  95  |         Unique Binary Search Trees ii          |       不同的二叉搜索树        |                     递归 / Recursion                      | 二叉搜索树的子树依然是二叉搜索树，我们遍历所有可能的root，根据root在1-n中的位置，将求left-right可能的BST转为求`left~root-1`和求`root+1~right`两个子问题，然后将可能的左BST和右BST和root做排列组合得到所有解 |                algorithm-parttern: recursion                 |
|  98  |          Validate Binary Search Tree           |        验证二叉搜索树         |              Binary Search Tree / 二叉搜索树              | [md](https://github.com/williamlwclwc/leetcode/blob/master/Notes/98.validate-binary-search-tree.md) |                algorithm-pattern: binary tree                |
|  99  |           Recover Binary Search Tree           |        恢复二叉搜索树         |                     BST / 二叉搜索树                      | [md](https://github.com/williamlwclwc/leetcode/blob/master/Notes/99.recover-binary-search-tree.md) |                  Daily Challenge 2020/08/08                  |
| 100  |                   Same Tree                    |           相同的树            |                   Binary Tree / 二叉树                    |                         递归遍历即可                         |                  Daily Challenge 2020/08/07                  |
| 102  |       Binary Tree Level Order Traversal        |       二叉树的层序遍历        |             Binary Tree, Queue / 二叉树，队列             | 从第一层的惟一的根节点开始，每次遍历访问一层树的节点，并将每个节点的左右子节点按顺序放入队列，直到队列为空 |                algorithm-pattern: binary tree                |
| 103  |    Binary Tree Zigzag Level Order Traversal    |      二叉树蛇形层序遍历       |             Binary Tree, Queue / 二叉树，队列             | 对102中的每层中间结果进行一次判断，若层数为奇数，则翻转该层结果，翻转操作为result = result[::-1] |                algorithm-pattern: binary tree                |
| 107  |      Binary Tree Level Order Traversal ii      |      二叉树的层序遍历ii       |             Binary Tree, Queue / 二叉树，队列             |   对102中得到的结果进行数组翻转即可: result = result[::-1]   |                algorithm-pattern: binary tree                |
| 104  |          Maximum Depth of Binary Tree          |       二叉树的最大深度        |                Binary Tree / 二叉树，分治                 |                      递归左右子树再合并                      |                algorithm-pattern: binary tree                |
| 109  |   Convert Sorted List to Binary Search Tree    |    有序链表转换二叉搜索树     | Binary Tree, Linked List, Recursion / 二叉树，链表 ，递归 |                    获取链表中点，递归建树                    |                  Daily Challenge 2020/08/18                  |
| 110  |              Balanced Binary Tree              |          平衡二叉树           |                   Binary Tree / 二叉树                    |                         递归求树深度                         |                  Daily Challenge 2020/08/17                  |
| 111  |          Minimum Depth of Binary Tree          |       二叉树的最小深度        |                   Binary Tree / 二叉树                    |                       注意特殊情况处理                       |                  Daily Challenge 2020/08/21                  |
| 114  |       Flatten Binary Tree to Linked List       |       二叉树展开为链表        |                   Binary Tree / 二叉树                    | [md](https://github.com/williamlwclwc/leetcode/blob/master/Notes/114.flatten-binary-tree-to-linked-list.md) |                  Daily Challenge 2020/08/02                  |
| 120  |                    Triangle                    |       三角形最小路径和        |                       DP / 动态规划                       |       先用递归解答，再用一个数组memo优化重复计算的部分       |                    algorithm-pattern: DP                     |
| 124  |          Binary Tree Maximum Path Sum          |     二叉树中的最大路径和      |                Binary Tree / 二叉树， 分治                |                     递归+更新全局最大值                      |                algorithm-pattern: binary tree                |
| 130  |               Surrounded Regions               |         被围绕的区域          |                   BFS, DFS / 深搜，广搜                   | [md](https://github.com/williamlwclwc/leetcode/blob/master/Notes/130.surrounded-regions.md) |                  Daily Challenge 2020/08/11                  |
| 132  |           Palindrome Partitioning II           |         分割回文串II          |                       DP / 动态规划                       | [leetcode题解](https://leetcode-cn.com/problems/palindrome-partitioning-ii/solution/132-fen-ge-hui-wen-chuan-iidong-tai-gui-3hqva/) |                    algorithm-pattern: DP                     |
| 133  |                  Clone Graph                   |            克隆图             |                   BFS, DFS / 深搜，广搜                   | [md](https://github.com/williamlwclwc/leetcode/blob/master/Notes/133.clone-graph.md) | Daily Challenge 2020/08/12, algorithm-pattern: stack & queue |
| 136  |                 Single Number                  |       只出现一次的数字        |                      二进制 / Binary                      | 利用异或运算的规律，出现两次的元素都会清0，最后剩下那个出现一次的元素 |                  algorithm-pattern: binary                   |
| 137  |                Single Number ii                |      只出现一次的数字ii       |                      二进制 / Binary                      | 遍历每一位，统计每一位上1的数量，若1的数量为3则舍弃，为1则加入到结果中。[参考解析](https://leetcode-cn.com/problems/single-number-ii/solution/137-zhi-chu-xian-yi-ci-de-shu-zi-iiwei-y-oa1w/) |                  algorithm-pattern: binary                   |
| 138  |         Copy List with Random Pointer          |     复制带随机指针的链表      |                    Linked List / 链表                     | 首先不管random指针复制一个链表，过程中保存一个哈希表{旧节点:对应的新节点}。通过此哈希我们可以得到新的random指针为hash[old.random]，这时我们再一次遍历原链表和复制链表将random指针依次复制上即可。 |                algorithm-pattern: Linked List                |
| 139  |                   Word Break                   |           单词拆分            |                       DP / 动态规划                       | [参考解析](https://leetcode-cn.com/problems/word-break/solution/shou-hui-tu-jie-san-chong-fang-fa-dfs-bfs-dong-tai) |                    algorithm-pattern: DP                     |
| 141  |               Linked List Cycle                |           环形链表            |                    Linked List / 链表                     | 快慢指针，快指针f从head.next出发，慢指针s从head出发，若有环则快慢指针每次循环距离将-1并最终将会相遇 |                algorithm-pattern: Linked List                |
| 142  |              Linked List Cycle ii              |          环形链表ii           |                    Linked List / 链表                     | 快慢指针为最优解，需要计算快慢指针行进距离以确保能够在环入口点相遇。首先和141一样让快慢指针相遇，此时慢指针后移一位，快指针回到head，之后快慢指针移速相同，相遇时即在环的入口点。计算过程见代码里的注释。 |                algorithm-pattern: Linked List                |
| 143  |                  Reorder List                  |           重排链表            |                    Linked List / 链表                     |    分为找中点(148)、翻转后一半链表(206)、再合并两部分链表    |                algorithm-pattern: Linked List                |
| 148  |                   Sort List                    |           排序链表            |                    Linked List / 链表                     | 链表的归并排序，先找中点分成左右两部分，再按顺序合并两部分。找中点需要用一快一慢两个指针，快指针需要从head.next开始以避免无限递归，left部分最后指定为None，合并时可使用dummy node |                algorithm-pattern: Linked List                |
| 150  |        Evaluate Reverse Polish Notation        |       逆波兰表达式求值        |                        Stack / 栈                         | 使用一个栈，遍历数组，遇到数字则数字入栈；遇到运算符，则出栈两个数字，执行运算，再将结果放回栈中。最后栈里剩下的数字就是最终的结果。 |               algorithm-pattern: Stack & Queue               |
| 153  |      Find Minimum in Rotated Sorted Array      |  寻找旋转排序数组中的最小值   |                 Binary Search / 二分查找                  | [参考解析](https://leetcode-cn.com/problems/find-minimum-in-rotated-sorted-array/solution/jian-dan-yi-dong-javac-pythonjspei-yang-zvoif/) |               algorithm-pattern: binary search               |
| 154  |    Find Minimum in Rotated Sorted Array II     | 寻找旋转排序数组中的最小值 II |                 Binary Search / 二分查找                  | [参考解析](https://leetcode-cn.com/problems/find-minimum-in-rotated-sorted-array/solution/jian-dan-yi-dong-javac-pythonjspei-yang-zvoif/) 在153的基础上加上对mid == end的处理即可 |               algorithm-pattern: binary search               |
| 155  |                   Min Stack                    |            最小栈             |                        Stack / 栈                         | 除了一个正常的栈之外，额外使用一个最小栈，每次入栈元素同时向最小栈中入该入栈元素对应的最小值，即最小栈当前最小值和入栈元素中较小的那个。获取最小值时返回最小栈的最上面的值即可。 |               algorithm-pattern: Stack & Queue               |
| 190  |                  Reverse Bits                  |         颠倒二进制位          |                      二进制 / Binary                      | 每次循环取出最后一位，左移相应31-0位然后加入res中，n每次右移一位直到n为0退出循环，最后返回res |                  algorithm-pattern: binary                   |
| 191  |                Number of 1 Bits                |           位1的个数           |                      二进制 / Binary                      | 每次循环判断最后一位是不是1，然后右移一位，直到n为0退出循环，返回计数即可 |                  algorithm-pattern: binary                   |
| 200  |               Number of Islands                |           岛屿数量            |               DFS, BFS / 深度或广度优先搜索               | 遍历所有元素，遇到1则计数+1，然后从这个1开始使用递归/栈/队列的方式进行深度广度优先搜索，将与1相连的岛都改成0,直到所有元素遍历完毕，返回计数 |               algorithm-pattern: Stack & Queue               |
| 201  |          Bitwise AND of Numbers Range          |        数字范围按位与         |                      二进制 / Binary                      | [md](https://github.com/williamlwclwc/leetcode/blob/master/Notes/201.bitwise-and-of-numbers-range.md) | Daily Challenge 2020/08/23, algorithm-pattern: Stack & Queue |
| 206  |              Reverse Linked List               |           翻转链表            |                    Linked List / 链表                     | 需要遍历指针p，额外指针prev(初始化为None)、n 。每次遍历循环中:  (1) 保存p.next的位置: n = p.next (2) 断开next指针，改为指向前一个: p.next = prev (3) 移动prev指针成为下次循环的前一个: prev = p (4) 移动p指针到保存的p.next的位置: p = n |                algorithm-pattern: Linked List                |
| 207  |                Course Schedule                 |            课程表             |         Topological Sorting, Graph / 拓扑排序, 图         | [md](https://github.com/williamlwclwc/leetcode/blob/master/Notes/207.course-schedule.md) |                  Daily Challenge 2020/08/04                  |
| 214  |              Shortest Palindrome               |          最短回文串           |                      String / 字符串                      |                  翻转，再去掉与原串重合部分                  |                  Daily Challenge 2020/08/29                  |
| 232  |          Implement Queue using Stacks          |         用栈实现队列          |                   Stack Queue / 栈 队列                   | 一个输入栈入栈输入队列元素，一个输出栈输出队首元素，当输出栈为空时，将输入栈的元素一次出栈，并入栈输出栈，最后将输出栈的栈顶元素输出即可 |               algorithm-pattern: Stack & Queue               |
| 234  |             Palindrome Linked List             |           回文链表            |                    Linked List / 链表                     | 先找链表中点(148)，然后翻转后半部分链表(206)，之后同时遍历前后两部分链表，比较每一个元素判断是否为回文链表即可 |                algorithm-pattern: Linked List                |
| 236  |    Lowest Common Ancestor of a Binary Tree     |     二叉树的最近公共祖先      |                Bianry Tree / 二叉树，分治                 | 从root开始递归二叉树，是pq或pq的公共祖先则返回root，否则返回null |                algorithm-pattern: binary tree                |
| 260  |               Single Number iii                |      只出现一次的数字iii      |                      二进制 / Binary                      | 和136相似，最后需要分开全员异或的结果a^b，方法是找到值为1的一位作为分组标准，将所有的数字分为ab两组，分别求异或，即得结果 |                  algorithm-pattern: binary                   |
| 278  |               First Bad Version                |       第一个错误的版本        |                 Binary Search / 二分查找                  |     二分查找模板换皮，需注意最后start end均不match的情况     |               algorithm-pattern: binary search               |
| 300  |         Longest Increasing Subsequence         |        最长递增子序列         |                       DP / 动态规划                       | 本题的DP五步见[md](https://github.com/williamlwclwc/leetcode/blob/master/Algorithm-Pattern-Notes/动态规划.md),此外[题解](https://leetcode-cn.com/problems/longest-increasing-subsequence/solution/shi-pin-tu-jie-zui-chang-shang-sheng-zi-xu-lie-by-/)提供的练习工具很不错 |                    algorithm-pattern: DP                     |
| 322  |                  Coin Change                   |           零钱兑换            |                       DP / 动态规划                       |                       完全背包系列问题                       |                    algorithm-pattern: DP                     |
| 332  |             Reconstruct Itinerary              |         重新安排行程          |                DFS, AdjList / 深搜，邻接表                | [md](https://github.com/williamlwclwc/leetcode/blob/master/Notes/332.reconstruct-itinerary.md) |                  Daily Challenge 2020/08/27                  |
| 336  |                Palindrome Pairs                |            回文对             |          Hash Table, Trie Tree / 哈希表，字典树           | [md](https://github.com/williamlwclwc/leetcode/blob/master/Notes/336.palindrome-pairs.md) |                  Daily Challenge 2020/08/06                  |
| 337  |                House Robber III                |           打家劫舍            |            DP, Binary Tree / 动态规划，二叉树             | [md](https://github.com/williamlwclwc/leetcode/blob/master/Notes/337.house-robber-iii.md) |                  Daily Challenge 2020/08/05                  |
| 338  |                 Counting Bits                  |          比特位计数           |                      二进制 / Binary                      |                  在191基础上加一个循环即可                   |                  algorithm-pattern: binary                   |
| 415  |                  Add Strings                   |          字符串相加           |           String, Two Pointers / 字符串，双指针           | [md](https://github.com/williamlwclwc/leetcode/blob/master/Notes/415.add-strings.md) |                  Daily Challenge 2020/08/03                  |
| 438  |         Find All Anagrams in a String          |     找到字符串中所有字母      |                 Sliding Window / 滑动窗口                 |     思路和567题相似，需要注意循环中left right自加的位置      |              algorithm-pattern: sliding window               |
| 450  |              Delete Node in a BST              |    删除二叉搜索树中的节点     |                   Binary Tree / 二叉树                    | 首先根据目标和当前节点的大小分三类递归找到要删除的节点，找到后再根据目标节点是否有左右子树分三类处理 [参考解析](https://leetcode-cn.com/problems/delete-node-in-a-bst/solution/miao-dong-jiu-wan-shi-liao-by-terry2020-tc0o/) |                algorithm-pattern: binary tree                |
| 459  |           Repeated Substring Pattern           |        重复的子字符串         |                      String / 字符串                      |                        循环取子串检验                        |                  Daily Challenge 2020/08/24                  |
| 491  |            Increasing Subsequences             |          递增子序列           |                DFS, Recursion / 深搜，递归                | [md](https://github.com/williamlwclwc/leetcode/blob/master/Notes/491.increasing-subsequences.md) |                  Daily Challenge 2020/08/25                  |
| 509  |                Fibonacci Number                |          斐波那契数           |                 递归 递归优化 / Recursion                 | 很容易用递归解出来，要优化的话要获取每次的F(n-1)和F(n-2)，F(n-1)就是前一次得到的结果，而F(n-2)是上一次的F(n-1)需要一个额外变量存储并同步更新 |                 algorithm-pattern: recursion                 |
| 529  |                  Minesweeper                   |           扫雷游戏            |                   BFS, DFS / 深搜，广搜                   |                       注意搜索不要重复                       |                  Daily Challenge 2020/08/20                  |
| 542  |                   01 Matrix                    |            01 矩阵            |                 BFS, Queue / 广搜， 队列                  | 使用层序广度优先搜索，[参考解析](https://leetcode-cn.com/problems/01-matrix/solution/2chong-bfs-xiang-jie-dp-bi-xu-miao-dong-by-sweetie/) |               algorithm-pattern: Stack & Queue               |
| 546  |                  Remove Boxes                  |           移除盒子            |                       DP / 动态规划                       |                                                              |                  Daily Challenge 2020/08/15                  |
| 557  |         Reverse Words in a String III          |    反转字符串中的单词 III     |                      String / 字符串                      |                       split翻转再join                        |                  Daily Challenge 2020/08/30                  |
| 567  |             Permutation in String              |         字符串的排列          |                 Sliding Window / 滑动窗口                 | 用dict存储s1的字符及出现次数，每次窗口滑动去掉第一个字符，加入最后一个字符，当s1 dict所有key的value都为0则证明找到了一个s2子串 |              algorithm-pattern: Sliding Window               |
| 647  |             Palindromic Substrings             |           回文子串            |                      String / 字符串                      |                          纯暴力即可                          |                  Daily Challenge 2020/08/19                  |
| 657  |             Robot Return to Origin             |      机器人能否返回原点       |                        Loop / 循环                        |                         循环计数即可                         |                  Daily Challenge 2020/08/28                  |
| 679  |                    24 Game                     |           24点游戏            |           Recursion or enumeration / 递归或枚举           |                            枚举法                            |                  Daily Challenge 2020/08/22                  |
| 696  |            Count Binary Substrings             |        计数二进制子串         |                      String / 字符串                      | [md](https://github.com/williamlwclwc/leetcode/blob/master/Notes/696.count-binary-substrings.md) |                  Daily Challenge 2020/08/10                  |
| 701  |        Insert into a Binary Search Tree        |    二叉搜索树中的插入操作     |              Binary Search Tree / 二叉搜索树              | 找到可插入的叶节点位置None(当前节点小于插入值，则向左子树root.left继续搜索，当前节点大于插入值，则向右子树root.right继续搜索，由于每个节点数值唯一，不考虑等于的情况)，将root.left / root.right的None改为要插入的节点即可 |                algorithm-pattern: binary tree                |
| 704  |                 Binary Search                  |           二分查找            |                 Binary Search / 二分查找                  |                         二分查找模板                         |               algorithm-pattern: binary search               |
| 733  |                   Flood Fill                   |           图像渲染            |                     Recursion / 递归                      |                           递归即可                           |                  Daily Challenge 2020/08/16                  |
| 841  |                 Keys and Rooms                 |          钥匙和房间           |                   DFS, BFS / 深搜，广搜                   |                       转换为图搜索即可                       |                  Daily Challenge 2020/08/31                  |
| 1143 |           Longest Common Subsequence           |        最长公共子序列         |                       DP / 动态规划                       | [参考解析和可视化练习](https://leetcode-cn.com/problems/longest-common-subsequence/solution/shi-pin-jiang-jie-shi-yong-dong-tai-gui-hua-qiu-ji/) |                    algorithm-pattern: DP                     |
| 1162 |          As Far from Land as Possible          |           地图分析            |                 BFS, Queue / 广搜， 队列                  |               与542相似，使用层序广度优先搜索                |               algorithm-pattern: Stack & Queue               |
