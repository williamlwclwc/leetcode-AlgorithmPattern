# 动态规划

## 动态规划概念

* 动态规划 = 递归 + 备忘录
* 动态规划将大问题变成小问题(递归)，并解决了小问题的重复计算(备忘录memo)
* 可由递归的自上而下转变成标准版的自底向上(或许能发现进一步优化)

### 使用场景

* 不能排序或交换
* 求解以下几类问题: 求最值，求是否可行，求可行个数

### 五要素

* 状态: dp数组的含义
* 方程: 状态转移方程
* 初始化: 最小状态的初始值是什么
* 循环顺序: 多层循环时内外遍历顺序
* 答案: 最后返回什么结果

### 热身题

[triangle](https://leetcode-cn.com/problems/triangle/): 先用dfs求解，再将重复计算的部分用memo数组优化掉

```python
import sys
class Solution:
    def minimumTotal(self, triangle: List[List[int]]) -> int:
        memo = [[sys.maxsize for _ in range(len(triangle[i]))] for i in range(len(triangle))]
        return self.dfs(memo, triangle, 0, 0)
    
    def dfs(self, memo, triangle, i, j):
        if i == len(triangle):
            return 0
        if memo[i][j] != sys.maxsize:
            return memo[i][j]
        memo[i][j] = min(self.dfs(memo, triangle, i+1, j), self.dfs(memo, triangle, i+1, j+1)) + triangle[i][j]
        return memo[i][j]
```

## 例题

### 矩阵DP 10%

* [minimum-path-sum](https://leetcode-cn.com/problems/minimum-path-sum/): 给定一个包含非负整数的 *m* x *n* 网格，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。

  * 递归memo和dp均可
  * dp数组意义为当前坐标的最短路径和
  * 递归公式为`dp[i][j]=min(dp[i-1][j], dp[i][j-1])+grid[i][j]`
  * 初始化第一行第一列，只能由上方左侧其一到达
  * 循环顺序先行后列，按行填入
  * 返回结果为dp右下角的数

  ```python
  class Solution:
      def minPathSum(self, grid: List[List[int]]) -> int:
          hashsum = [[-1 for _ in range(len(grid[i]))] for i in range(len(grid))]
          return self.minPath(hashsum, grid, 0, 0)
  
      def minPath(self, hashsum, grid, i, j):
          if i == len(grid) or j == len(grid[0]):
              return 0
  
          if hashsum[i][j] != -1:
              return hashsum[i][j]
          
          if i < len(grid)-1 and j < len(grid[0])-1:
              hashsum[i][j] = min(
                  self.minPath(hashsum, grid, i+1, j) + grid[i][j],
                  self.minPath(hashsum, grid, i, j+1) + grid[i][j]
              )
          elif i == len(grid)-1:
              hashsum[i][j] = self.minPath(hashsum, grid, i, j+1) + grid[i][j]
          elif j == len(grid[0])-1:
              hashsum[i][j] = self.minPath(hashsum, grid, i+1, j) + grid[i][j]
          return hashsum[i][j]
  ```

  ```python
  class Solution:
      def minPathSum(self, grid: List[List[int]]) -> int:
          hashsum = [[-1 for _ in range(len(grid[i]))] for i in range(len(grid))]
          # init row 0 col 0
          hashsum[0][0] = grid[0][0]
          for i in range(1, len(grid[0])):
              hashsum[0][i] = hashsum[0][i-1] + grid[0][i]
          for j in range(1, len(grid)):
              hashsum[j][0] = hashsum[j-1][0] + grid[j][0]
          # fill the hashsum row by row
          for i in range(1, len(grid)):
              for j in range(1, len(grid[0])):
                  hashsum[i][j] = min(hashsum[i][j-1], hashsum[i-1][j]) + grid[i][j]
          
          return hashsum[len(grid)-1][len(grid[0])-1]
  ```

* [unique-paths](https://leetcode-cn.com/problems/unique-paths/): 一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为“Start” ）。 机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）。 问总共有多少条不同的路径？

  * dp数组定义为到达坐标(i, j)的走法共有`dp[i][j]`种
  * 递归公式: `dp[i][j] = dp[i-1][j] + dp[i][j-1]`, 可以由上方或左侧到达
  * 初始化，第一行第一列都是1,其余位置随意
  * 循环顺序先行后列依次填数即可
  * 返回结果为右下角的dp值

  ```python
  class Solution:
      def uniquePaths(self, m: int, n: int) -> int:
          numPaths = [[-1 for _ in range(n)] for _ in range(m)]
          for i in range(m):
              numPaths[i][0] = 1
          for i in range(n):
              numPaths[0][i] = 1
          for i in range(1, m):
              for j in range(1, n):
                  numPaths[i][j] = numPaths[i-1][j] + numPaths[i][j-1]
          
          return numPaths[m-1][n-1]
  ```

* [unique-paths-ii](https://leetcode-cn.com/problems/unique-paths-ii/): 一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为“Start” ）。 机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）。 问总共有多少条不同的路径？ 现在考虑网格中有障碍物。那么从左上角到右下角将会有多少条不同的路径？

  * 遇上一题大体相同，但是障碍物以及被障碍物阻挡的dp值均为0，注意初始化的过程
  
  ```python
  class Solution:
      def uniquePathsWithObstacles(self, obstacleGrid: List[List[int]]) -> int:
          m = len(obstacleGrid)
          n = len(obstacleGrid[0])
          if obstacleGrid[0][0] == 1 or obstacleGrid[m-1][n-1] == 1:
              return 0
          numPaths = [[-1 if obstacleGrid[i][j] == 0 else 0 for j in range(n)] for i in range(m)]
          numPaths[0][0] = 1
          for i in range(1, m):
              if obstacleGrid[i][0] == 0:
                  numPaths[i][0] = numPaths[i-1][0]
              else:
                  numPaths[i][0] = 0
          for i in range(1, n):
              if obstacleGrid[0][i] == 0:
                  numPaths[0][i] = numPaths[0][i-1]
              else:
                  numPaths[0][i] = 0
          
          for i in range(1, m):
              for j in range(1, n):
                  if numPaths[i][j] == 0:
                      continue
                  else:
                      numPaths[i][j] = numPaths[i-1][j] + numPaths[i][j-1]
          
          return numPaths[m-1][n-1]
  ```

### 序列DP 40%

* [climbing-stairs](https://leetcode-cn.com/problems/climbing-stairs/)

  * 此题可转化为Fibonacci，因为登上第n层的方法可由n-1层的方法再向上一层或n-2层的方法再向上两层的方法和组成

  ```python
  class Solution:
      def climbStairs(self, n: int) -> int:
          if n == 1 or n == 2:
              return n
          dp = [0 for _ in range(n+1)]
          # dp[i] = dp[i-1] + dp[i-2]
          dp[1] = 1
          dp[2] = 2
          for i in range(3, n+1):
              dp[i] = dp[i-1] + dp[i-2]
  		return dp[n]
  # further optimize space complexity
  class Solution:
      def climbStairs(self, n: int) -> int:
          if n == 1 or n == 2:
              return n
          # dp[i] = dp[i-1] + dp[i-2]
          dp1 = 1
          dp2 = 2
          for i in range(3, n+1):
              temp = dp2
              dp2 = dp1 + dp2
              dp1 = temp
          return dp2
  ```

* [jump-game](https://leetcode-cn.com/problems/jump-game/)

  * 不需要DP，保存目前能到达的最大距离maxDes
  * 循环遍历nums，如果当前i不能到达直接return False
  * 如果可以到达，更新maxDes，取和从nums[i] + i (从i出发最大走nums[i])中较大者

  ```python
  class Solution:
      def canJump(self, nums: List[int]) -> bool:
          maxDes = nums[0]
          for i in range(1, len(nums)):
              if maxDes < i:
                  return False
              else:
                  maxDes = max(maxDes, nums[i]+i)
          return True
  ```

* [jump-game-ii](https://leetcode-cn.com/problems/jump-game-ii/)

  * dp定义为到达位置i最小需要jump dp[i]次

  ```python
  class Solution:
      def jump(self, nums: List[int]) -> int:
          dp = [-1] * len(nums)
          dp[0] = 0
          for i in range(len(nums)):
              end_idx = min(i+nums[i]+1, len(nums))
              for j in range(i, end_idx):
                  if dp[j] == -1:
                      dp[j] = 1 + dp[i]
                  else:
                      dp[j] = min(dp[j], 1+dp[i])
          return dp[len(nums)-1]
  ```

* [palindrome-partitioning-ii](https://leetcode-cn.com/problems/palindrome-partitioning-ii/)

  ```python
  class Solution:
      def minCut(self, s: str) -> int:
          # quickly check whether s[0:i+1] is palindrome
          isPalindrome = [[False for _ in range(len(s))] for _ in range(len(s))]
          for i in range(len(s)-1, -1, -1):
              for j in range(len(s)):
                  if s[i] == s[j]:
                      if j-i <= 1 or isPalindrome[i+1][j-1]:
                          isPalindrome[i][j] = True
          # dp[i]: s[0:i+1] minimum cuts
          dp = [-1 for _ in range(len(s))]
          for i in range(len(s)):
              if isPalindrome[0][i]:
                  dp[i] = 0
                  continue
              for j in range(0, i):
                  if isPalindrome[j+1][i]:
                      if dp[i] == -1 or dp[i] > dp[j]+1:
                          dp[i] = dp[j]+1
          return dp[len(s)-1]
  ```

* [longest-increasing-subsequence](https://leetcode-cn.com/problems/longest-increasing-subsequence/)

  ```
  
  ```

* [word-break](https://leetcode-cn.com/problems/word-break/)

  ```
  
  ```

### 双序列DP 40%



### 背包DP 10%